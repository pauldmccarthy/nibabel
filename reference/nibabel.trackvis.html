<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Neuroimaging in Python &mdash; NiBabel 2.0.2 documentation</title>
    
    <link rel="stylesheet" href="../_static/nibabel.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="NiBabel 2.0.2 documentation" href="../index.html" />
    <link rel="up" title="API Documentation" href="../api.html" />
    <link rel="next" title="eulerangles" href="nibabel.eulerangles.html" />
    <link rel="prev" title="parrec" href="nibabel.parrec.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience">

  </head>
  <body role="document">
<div style="background-color: white; text-align: left; padding-left: 150px; padding-bottom:50px; padding-top:20px; background-image: url(../_static/nipy-logo-bg-138x120.png); background-repeat: no-repeat;">
<h1>NiBabel</h1>
<h3 style="margin-top:-5px;color:#2f83c8">Access a cacophony of neuro-imaging file formats</h3>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="nibabel.eulerangles.html" title="eulerangles"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="nibabel.parrec.html" title="parrec"
             accesskey="P">previous</a> |</li>
  <li><a href="http://nipy.org/">Community</a> |&nbsp;</li>
  <li><a href="../index.html">NiBabel Home</a> |&nbsp;</li>
  <li><a href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing list</a> |&nbsp;</li>
  <li><a href="legal.html">License</a> |&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../api.html" accesskey="U">API Documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">trackvis</span></code></a><ul>
<li><a class="reference internal" href="#dataerror"><code class="docutils literal"><span class="pre">DataError</span></code></a></li>
<li><a class="reference internal" href="#headererror"><code class="docutils literal"><span class="pre">HeaderError</span></code></a></li>
<li><a class="reference internal" href="#trackvisfile"><code class="docutils literal"><span class="pre">TrackvisFile</span></code></a></li>
<li><a class="reference internal" href="#trackvisfileerror"><code class="docutils literal"><span class="pre">TrackvisFileError</span></code></a></li>
<li><a class="reference internal" href="#aff-from-hdr">aff_from_hdr</a></li>
<li><a class="reference internal" href="#aff-to-hdr">aff_to_hdr</a></li>
<li><a class="reference internal" href="#empty-header">empty_header</a></li>
<li><a class="reference internal" href="#read">read</a></li>
<li><a class="reference internal" href="#write">write</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="nibabel.parrec.html"
                        title="previous chapter"><code class="docutils literal"><span class="pre">parrec</span></code></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="nibabel.eulerangles.html"
                        title="next chapter"><code class="docutils literal"><span class="pre">eulerangles</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/nibabel.trackvis.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<p><img src="../_static/reggie.png" alt="Reggie -- the one" /></p>

        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-nibabel.trackvis">
<span id="trackvis"></span><h1><code class="xref py py-mod docutils literal"><span class="pre">trackvis</span></code><a class="headerlink" href="#module-nibabel.trackvis" title="Permalink to this headline">¶</a></h1>
<p>Read and write trackvis files</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.trackvis.DataError" title="nibabel.trackvis.DataError"><code class="xref py py-obj docutils literal"><span class="pre">DataError</span></code></a></td>
<td>Error in trackvis data</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.trackvis.HeaderError" title="nibabel.trackvis.HeaderError"><code class="xref py py-obj docutils literal"><span class="pre">HeaderError</span></code></a></td>
<td>Error in trackvis header</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.trackvis.TrackvisFile" title="nibabel.trackvis.TrackvisFile"><code class="xref py py-obj docutils literal"><span class="pre">TrackvisFile</span></code></a>(streamlines[,&nbsp;mapping,&nbsp;...])</td>
<td>Convenience class to encapsulate trackvis file information</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.trackvis.TrackvisFileError" title="nibabel.trackvis.TrackvisFileError"><code class="xref py py-obj docutils literal"><span class="pre">TrackvisFileError</span></code></a></td>
<td>Error from TrackvisFile class</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.trackvis.aff_from_hdr" title="nibabel.trackvis.aff_from_hdr"><code class="xref py py-obj docutils literal"><span class="pre">aff_from_hdr</span></code></a>(trk_hdr[,&nbsp;atleast_v2])</td>
<td>Return voxel to mm affine from trackvis header</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.trackvis.aff_to_hdr" title="nibabel.trackvis.aff_to_hdr"><code class="xref py py-obj docutils literal"><span class="pre">aff_to_hdr</span></code></a>(affine,&nbsp;trk_hdr[,&nbsp;pos_vox,&nbsp;set_order])</td>
<td>Set affine <cite>affine</cite> into trackvis header <cite>trk_hdr</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.trackvis.empty_header" title="nibabel.trackvis.empty_header"><code class="xref py py-obj docutils literal"><span class="pre">empty_header</span></code></a>([endianness,&nbsp;version])</td>
<td>Empty trackvis header</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.trackvis.read" title="nibabel.trackvis.read"><code class="xref py py-obj docutils literal"><span class="pre">read</span></code></a>(fileobj[,&nbsp;as_generator,&nbsp;points_space])</td>
<td>Read trackvis file, return streamlines, header</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.trackvis.write" title="nibabel.trackvis.write"><code class="xref py py-obj docutils literal"><span class="pre">write</span></code></a>(fileobj,&nbsp;streamlines[,&nbsp;hdr_mapping,&nbsp;...])</td>
<td>Write header and <cite>streamlines</cite> to trackvis file <cite>fileobj</cite></td>
</tr>
</tbody>
</table>
<div class="section" id="dataerror">
<h2><a class="reference internal" href="#nibabel.trackvis.DataError" title="nibabel.trackvis.DataError"><code class="xref py py-class docutils literal"><span class="pre">DataError</span></code></a><a class="headerlink" href="#dataerror" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.trackvis.DataError">
<em class="property">class </em><code class="descclassname">nibabel.trackvis.</code><code class="descname">DataError</code><a class="headerlink" href="#nibabel.trackvis.DataError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Error in trackvis data</p>
<dl class="method">
<dt id="nibabel.trackvis.DataError.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.trackvis.DataError.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="headererror">
<h2><a class="reference internal" href="#nibabel.trackvis.HeaderError" title="nibabel.trackvis.HeaderError"><code class="xref py py-class docutils literal"><span class="pre">HeaderError</span></code></a><a class="headerlink" href="#headererror" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.trackvis.HeaderError">
<em class="property">class </em><code class="descclassname">nibabel.trackvis.</code><code class="descname">HeaderError</code><a class="headerlink" href="#nibabel.trackvis.HeaderError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Error in trackvis header</p>
<dl class="method">
<dt id="nibabel.trackvis.HeaderError.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.trackvis.HeaderError.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="trackvisfile">
<h2><a class="reference internal" href="#nibabel.trackvis.TrackvisFile" title="nibabel.trackvis.TrackvisFile"><code class="xref py py-class docutils literal"><span class="pre">TrackvisFile</span></code></a><a class="headerlink" href="#trackvisfile" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.trackvis.TrackvisFile">
<em class="property">class </em><code class="descclassname">nibabel.trackvis.</code><code class="descname">TrackvisFile</code><span class="sig-paren">(</span><em>streamlines</em>, <em>mapping=None</em>, <em>endianness=None</em>, <em>filename=None</em>, <em>points_space=None</em>, <em>affine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.trackvis.TrackvisFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Convenience class to encapsulate trackvis file information</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>streamlines</strong> : sequence</p>
<blockquote>
<div><p>sequence of streamlines.  This object does not accept generic iterables
as input because these can be consumed and make the object unusable.
Please use the function interface to work with generators / iterables</p>
</div></blockquote>
<p><strong>mapping</strong> : None or mapping</p>
<blockquote>
<div><p>Mapping defining header attributes</p>
</div></blockquote>
<p><strong>endianness</strong> : {None, &#8216;&lt;&#8217;, &#8216;&gt;&#8217;}</p>
<blockquote>
<div><p>Set here explicit endianness if required.  Endianness otherwise inferred
from <cite>streamlines</cite></p>
</div></blockquote>
<p><strong>filename</strong> : None or str, optional</p>
<blockquote>
<div><p>filename</p>
</div></blockquote>
<p><strong>points_space</strong> : {None, &#8216;voxel&#8217;, &#8216;rasmm&#8217;}, optional</p>
<blockquote>
<div><p>Space in which streamline points are expressed in memory.  Default
(None) means streamlines contain points in trackvis <em>voxmm</em> space (voxel
positions * voxel sizes).  &#8216;voxel&#8217; means points are in voxel space (and
need to be multiplied by voxel size for saving in file).  &#8216;rasmm&#8217; mean
the points are expressed in mm space according to the affine.  See
<code class="docutils literal"><span class="pre">read</span></code> and <code class="docutils literal"><span class="pre">write</span></code> function docstrings for more detail.</p>
</div></blockquote>
<p><strong>affine</strong> : None or (4,4) ndarray, optional</p>
<blockquote class="last">
<div><p>Affine expressing relationship of voxels in an image to mm in RAS mm
space. If &#8216;points_space&#8217; is not None, you can use this to give the
relationship between voxels, rasmm and voxmm space (above).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nibabel.trackvis.TrackvisFile.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>streamlines</em>, <em>mapping=None</em>, <em>endianness=None</em>, <em>filename=None</em>, <em>points_space=None</em>, <em>affine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.trackvis.TrackvisFile.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="nibabel.trackvis.TrackvisFile.from_file">
<em class="property">classmethod </em><code class="descname">from_file</code><span class="sig-paren">(</span><em>klass</em>, <em>file_like</em>, <em>points_space=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.trackvis.TrackvisFile.from_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.trackvis.TrackvisFile.get_affine">
<code class="descname">get_affine</code><span class="sig-paren">(</span><em>atleast_v2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.trackvis.TrackvisFile.get_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Get affine from header in object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>aff</strong> : (4,4) ndarray</p>
<blockquote>
<div><p>affine from header</p>
</div></blockquote>
<p><strong>atleast_v2</strong> : None or bool, optional</p>
<blockquote class="last">
<div><p>See <code class="docutils literal"><span class="pre">aff_from_hdr</span></code> docstring for detail.  If True, require valid
affine in <code class="docutils literal"><span class="pre">vox_to_ras</span></code> field of header.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This method currently works for trackvis version 1 headers, but we
consider it unsafe for version 1 headers, and in future versions of
nibabel we will raise an error for trackvis headers &lt; version 2.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.trackvis.TrackvisFile.set_affine">
<code class="descname">set_affine</code><span class="sig-paren">(</span><em>affine</em>, <em>pos_vox=None</em>, <em>set_order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.trackvis.TrackvisFile.set_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Set affine <cite>affine</cite> into trackvis header</p>
<p>Affine is mapping from voxel space to Nifti RAS) output coordinate
system convention; x: Left -&gt; Right, y: Posterior -&gt; Anterior, z:
Inferior -&gt; Superior.  Sets affine if possible, and voxel sizes, and voxel
axis ordering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>affine</strong> : (4,4) array-like</p>
<blockquote>
<div><p>Affine voxel to mm transformation</p>
</div></blockquote>
<p><strong>pos_vos</strong> : None or bool, optional</p>
<blockquote>
<div><p>If None, currently defaults to False - this will change in future
versions of nibabel.  If False, allow negative voxel sizes in header to
record axis flips.  Negative voxels cause problems for trackvis (the
application).  If True, enforce positive voxel sizes.</p>
</div></blockquote>
<p><strong>set_order</strong> : None or bool, optional</p>
<blockquote>
<div><p>If None, currently defaults to False - this will change in future
versions of nibabel.  If False, do not set <code class="docutils literal"><span class="pre">voxel_order</span></code> field in
<cite>trk_hdr</cite>.  If True, calculcate <code class="docutils literal"><span class="pre">voxel_order</span></code> from <cite>affine</cite> and set
into <cite>trk_hdr</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>None</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.trackvis.TrackvisFile.to_file">
<code class="descname">to_file</code><span class="sig-paren">(</span><em>file_like</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.trackvis.TrackvisFile.to_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="trackvisfileerror">
<h2><a class="reference internal" href="#nibabel.trackvis.TrackvisFileError" title="nibabel.trackvis.TrackvisFileError"><code class="xref py py-class docutils literal"><span class="pre">TrackvisFileError</span></code></a><a class="headerlink" href="#trackvisfileerror" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.trackvis.TrackvisFileError">
<em class="property">class </em><code class="descclassname">nibabel.trackvis.</code><code class="descname">TrackvisFileError</code><a class="headerlink" href="#nibabel.trackvis.TrackvisFileError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Error from TrackvisFile class</p>
<dl class="method">
<dt id="nibabel.trackvis.TrackvisFileError.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.trackvis.TrackvisFileError.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="aff-from-hdr">
<h2>aff_from_hdr<a class="headerlink" href="#aff-from-hdr" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.trackvis.aff_from_hdr">
<code class="descclassname">nibabel.trackvis.</code><code class="descname">aff_from_hdr</code><span class="sig-paren">(</span><em>trk_hdr</em>, <em>atleast_v2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.trackvis.aff_from_hdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return voxel to mm affine from trackvis header</p>
<p>Affine is mapping from voxel space to Nifti (RAS) output coordinate
system convention; x: Left -&gt; Right, y: Posterior -&gt; Anterior, z:
Inferior -&gt; Superior.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>trk_hdr</strong> : mapping</p>
<blockquote>
<div><p>Mapping with trackvis header keys <code class="docutils literal"><span class="pre">version</span></code>. If <code class="docutils literal"><span class="pre">version</span> <span class="pre">==</span> <span class="pre">2</span></code>, we
also expect <code class="docutils literal"><span class="pre">vox_to_ras</span></code>.</p>
</div></blockquote>
<p><strong>atleast_v2</strong> : None or bool</p>
<blockquote>
<div><p>If None, currently defaults to False.  This will change to True in
future versions.  If True, require that there is a valid &#8216;vox_to_ras&#8217;
affine, raise HeaderError otherwise.  If False, look for valid
&#8216;vox_to_ras&#8217; affine, but fall back to best guess from version 1 fields
otherwise.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>aff</strong> : (4,4) array</p>
<blockquote class="last">
<div><p>affine giving mapping from voxel coordinates (affine applied on
the left to points on the right) to millimeter coordinates in the
RAS coordinate system</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Our initial idea was to try and work round the deficiencies of the version 1
format by using the DICOM orientation fields to store the affine.  This
proved difficult in practice because trackvis (the application) doesn&#8217;t
allow negative voxel sizes (needed for recording axis flips) and sets the
origin field to 0. In future, we&#8217;ll raise an error rather than try and
estimate the affine from version 1 fields</p>
</dd></dl>

</div>
<div class="section" id="aff-to-hdr">
<h2>aff_to_hdr<a class="headerlink" href="#aff-to-hdr" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.trackvis.aff_to_hdr">
<code class="descclassname">nibabel.trackvis.</code><code class="descname">aff_to_hdr</code><span class="sig-paren">(</span><em>affine</em>, <em>trk_hdr</em>, <em>pos_vox=None</em>, <em>set_order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.trackvis.aff_to_hdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Set affine <cite>affine</cite> into trackvis header <cite>trk_hdr</cite></p>
<p>Affine is mapping from voxel space to Nifti RAS) output coordinate
system convention; x: Left -&gt; Right, y: Posterior -&gt; Anterior, z:
Inferior -&gt; Superior.  Sets affine if possible, and voxel sizes, and voxel
axis ordering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>affine</strong> : (4,4) array-like</p>
<blockquote>
<div><p>Affine voxel to mm transformation</p>
</div></blockquote>
<p><strong>trk_hdr</strong> : mapping</p>
<blockquote>
<div><p>Mapping implementing __setitem__</p>
</div></blockquote>
<p><strong>pos_vos</strong> : None or bool</p>
<blockquote>
<div><p>If None, currently defaults to False - this will change in future
versions of nibabel.  If False, allow negative voxel sizes in header to
record axis flips.  Negative voxels cause problems for trackvis (the
application).  If True, enforce positive voxel sizes.</p>
</div></blockquote>
<p><strong>set_order</strong> : None or bool</p>
<blockquote>
<div><p>If None, currently defaults to False - this will change in future
versions of nibabel.  If False, do not set <code class="docutils literal"><span class="pre">voxel_order</span></code> field in
<cite>trk_hdr</cite>.  If True, calculcate <code class="docutils literal"><span class="pre">voxel_order</span></code> from <cite>affine</cite> and set
into <cite>trk_hdr</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>None</strong> :</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>version 2 of the trackvis header has a dedicated field for the nifti RAS
affine. In theory trackvis 1 has enough information to store an affine, with
the fields &#8216;origin&#8217;, &#8216;voxel_size&#8217; and &#8216;image_orientation_patient&#8217;.
Unfortunately, to be able to store any affine, we&#8217;d need to be able to set
negative voxel sizes, to encode axis flips. This is because
&#8216;image_orientation_patient&#8217; is only two columns of the 3x3 rotation matrix,
and we need to know the number of flips to reconstruct the third column
reliably.  It turns out that negative flips upset trackvis (the
application).  The application also ignores the origin field, and may not
use the &#8216;image_orientation_patient&#8217; field.</p>
</dd></dl>

</div>
<div class="section" id="empty-header">
<h2>empty_header<a class="headerlink" href="#empty-header" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.trackvis.empty_header">
<code class="descclassname">nibabel.trackvis.</code><code class="descname">empty_header</code><span class="sig-paren">(</span><em>endianness=None</em>, <em>version=2</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.trackvis.empty_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Empty trackvis header</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>endianness</strong> : {&#8216;&lt;&#8217;,&#8217;&gt;&#8217;}, optional</p>
<blockquote>
<div><p>Endianness of empty header to return. Default is native endian.</p>
</div></blockquote>
<p><strong>version</strong> : int, optional</p>
<blockquote>
<div><p>Header version.  1 or 2.  Default is 2</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>hdr</strong> : structured array</p>
<blockquote class="last">
<div><p>structured array containing empty trackvis header</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The trackvis header can store enough information to give an affine
mapping between voxel and world space.  Often this information is
missing.  We make no attempt to fill it with sensible defaults on
the basis that, if the information is missing, it is better to be
explicit.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">empty_header</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;version&#39;</span><span class="p">])</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asscalar</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;id_string&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="n">b</span><span class="s1">&#39;TRACK&#39;</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">endian_codes</span><span class="p">[</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;version&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span><span class="p">]</span> <span class="o">==</span> <span class="n">native_code</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">empty_header</span><span class="p">(</span><span class="n">swapped_code</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">endian_codes</span><span class="p">[</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;version&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span><span class="p">]</span> <span class="o">==</span> <span class="n">swapped_code</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdr</span> <span class="o">=</span> <span class="n">empty_header</span><span class="p">(</span><span class="n">version</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;version&#39;</span><span class="p">])</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="read">
<h2>read<a class="headerlink" href="#read" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.trackvis.read">
<code class="descclassname">nibabel.trackvis.</code><code class="descname">read</code><span class="sig-paren">(</span><em>fileobj</em>, <em>as_generator=False</em>, <em>points_space=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.trackvis.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read trackvis file, return streamlines, header</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileobj</strong> : string or file-like object</p>
<blockquote>
<div><p>If string, a filename; otherwise an open file-like object
pointing to trackvis file (and ready to read from the beginning
of the trackvis header data)</p>
</div></blockquote>
<p><strong>as_generator</strong> : bool, optional</p>
<blockquote>
<div><p>Whether to return tracks as sequence (False, default) or as a generator
(True).</p>
</div></blockquote>
<p><strong>points_space</strong> : {None, &#8216;voxel&#8217;, &#8216;rasmm&#8217;}, optional</p>
<blockquote>
<div><p>The coordinates in which you want the points in the <em>output</em> streamlines
expressed.  If None, then return the points exactly as they are stored
in the trackvis file. The points will probably be in trackviz voxmm
space - see Notes for <code class="docutils literal"><span class="pre">write</span></code> function.  If &#8216;voxel&#8217;, we convert the
points to voxel space simply by dividing by the recorded voxel size.  If
&#8216;rasmm&#8217; we&#8217;ll convert the points to RAS mm space (real space). For
&#8216;rasmm&#8217; we check if the affine is set and matches the voxel sizes and
voxel order.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>streamlines</strong> : sequence or generator</p>
<blockquote>
<div><p>Returns sequence if <cite>as_generator</cite> is False, generator if True.  Value is
sequence or generator of 3 element sequences with elements:</p>
<ol class="arabic simple">
<li>points : ndarray shape (N,3)
where N is the number of points</li>
<li>scalars : None or ndarray shape (N, M)
where M is the number of scalars per point</li>
<li>properties : None or ndarray shape (P,)
where P is the number of properties</li>
</ol>
</div></blockquote>
<p><strong>hdr</strong> : structured array</p>
<blockquote class="last">
<div><p>structured array with trackvis header fields</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The endianness of the input data can be deduced from the endianness
of the returned <cite>hdr</cite> or <cite>streamlines</cite></p>
<p>Points are in trackvis <em>voxel mm</em>.  Each track has N points, each with 3
coordinates, <code class="docutils literal"><span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z</span></code>, where <code class="docutils literal"><span class="pre">x</span></code> is the floating point voxel coordinate
along the first image axis, multiplied by the voxel size for that axis.</p>
</dd></dl>

</div>
<div class="section" id="write">
<h2>write<a class="headerlink" href="#write" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.trackvis.write">
<code class="descclassname">nibabel.trackvis.</code><code class="descname">write</code><span class="sig-paren">(</span><em>fileobj</em>, <em>streamlines</em>, <em>hdr_mapping=None</em>, <em>endianness=None</em>, <em>points_space=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.trackvis.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write header and <cite>streamlines</cite> to trackvis file <cite>fileobj</cite></p>
<p>The parameters from the streamlines override conflicting parameters
in the <cite>hdr_mapping</cite> information.  In particular, the number of
streamlines, the number of scalars, and the number of properties are
written according to <cite>streamlines</cite> rather than <cite>hdr_mapping</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileobj</strong> : filename or file-like</p>
<blockquote>
<div><p>If filename, open file as &#8216;wb&#8217;, otherwise <cite>fileobj</cite> should be an
open file-like object, with a <code class="docutils literal"><span class="pre">write</span></code> method.</p>
</div></blockquote>
<p><strong>streamlines</strong> : iterable</p>
<blockquote>
<div><p>iterable returning 3 element sequences with elements:</p>
<ol class="arabic simple">
<li>points : ndarray shape (N,3)
where N is the number of points</li>
<li>scalars : None or ndarray shape (N, M)
where M is the number of scalars per point</li>
<li>properties : None or ndarray shape (P,)
where P is the number of properties</li>
</ol>
<p>If <cite>streamlines</cite> has a <code class="docutils literal"><span class="pre">len</span></code> (for example, it is a list or a tuple),
then we can write the number of streamlines into the header.  Otherwise
we write 0 for the number of streamlines (a valid trackvis header) and
write streamlines into the file until the iterable is exhausted.
M - the number of scalars - has to be the same for each streamline in
<cite>streamlines</cite>.  Similarly for P. See <cite>points_space</cite> and Notes for more
detail on the coordinate system for <code class="docutils literal"><span class="pre">points</span></code> above.</p>
</div></blockquote>
<p><strong>hdr_mapping</strong> : None, ndarray or mapping, optional</p>
<blockquote>
<div><p>Information for filling header fields.  Can be something
dict-like (implementing <code class="docutils literal"><span class="pre">items</span></code>) or a structured numpy array</p>
</div></blockquote>
<p><strong>endianness</strong> : {None, &#8216;&lt;&#8217;, &#8216;&gt;&#8217;}, optional</p>
<blockquote>
<div><p>Endianness of file to be written.  &#8216;&lt;&#8217; is little-endian, &#8216;&gt;&#8217; is
big-endian.  None (the default) is to use the endianness of the
<cite>streamlines</cite> data.</p>
</div></blockquote>
<p><strong>points_space</strong> : {None, &#8216;voxel&#8217;, &#8216;rasmm&#8217;}, optional</p>
<blockquote>
<div><p>The coordinates in which the points in the input streamlines are
expressed.  If None, then assume the points are as you want them
(probably trackviz voxmm space - see Notes).  If &#8216;voxel&#8217;, the points are
in voxel space, and we will transform them to trackviz voxmm space.  If
&#8216;rasmm&#8217; the points are in RAS mm space (real space).  We transform them
to trackvis voxmm space.  If &#8216;voxel&#8217; or &#8216;rasmm&#8217; we insist that the voxel
sizes and ordering are set to non-default values.  If &#8216;rasmm&#8217; we also
check if the affine is set and matches the voxel sizes</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>None</strong> :</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Trackvis (the application) expects the <code class="docutils literal"><span class="pre">points</span></code> in the streamlines be in
what we call <em>trackviz voxmm</em> coordinates.  If we have a point (x, y, z) in
voxmm coordinates, and <code class="docutils literal"><span class="pre">voxel_size</span></code> has the voxel sizes for each of the 3
dimensions, then x, y, z refer to mm in voxel space. Thus if i, j, k is a
point in voxel coordinates, then <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">*</span> <span class="pre">voxel_size[0];</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">j</span> <span class="pre">*</span>
<span class="pre">voxel_size[1];</span> <span class="pre">z</span> <span class="pre">=</span> <span class="pre">k</span> <span class="pre">*</span> <span class="pre">voxel_size[2]</span></code>.   The spatial direction of x, y and
z are defined with the &#8220;voxel_order&#8221; field.  For example, if the original
image had RAS voxel ordering then &#8220;voxel_order&#8221; would be &#8220;RAS&#8221;.  RAS here
refers to the spatial direction of the voxel axes: &#8220;R&#8221; means that moving
along first voxel axis moves from left to right in space, &#8220;A&#8221; -&gt; second axis
goes from posterior to anterior, &#8220;S&#8221; -&gt; inferior to superior.  If
&#8220;voxel_order&#8221; is empty we assume &#8220;LPS&#8221;.</p>
<p>This information comes from some helpful replies on the trackviz forum about
<a class="reference external" href="http://trackvis.org/blog/forum/diffusion-toolkit-usage/interpretation-of-track-point-coordinates">interpreting point coordiantes</a></p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">file_obj</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pts0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pts1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">streamlines</span> <span class="o">=</span> <span class="p">([(</span><span class="n">pts0</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="p">(</span><span class="n">pts1</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">write</span><span class="p">(</span><span class="n">file_obj</span><span class="p">,</span> <span class="n">streamlines</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">file_obj</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># returns 0 in python 3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">streams</span><span class="p">,</span> <span class="n">hdr</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">file_obj</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">streams</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>If there are too many streamlines to fit in memory, you can pass an iterable
thing instead of a list</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">file_obj</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">yield</span> <span class="p">(</span><span class="n">pts0</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">yield</span> <span class="p">(</span><span class="n">pts0</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">write</span><span class="p">(</span><span class="n">file_obj</span><span class="p">,</span> <span class="n">gen</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">file_obj</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">streams</span><span class="p">,</span> <span class="n">hdr</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">file_obj</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">streams</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2006-2015, Matthew Brett, Michael Hanke and Eric Larson &lt;nipy-devel@neuroimaging.scipy.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>