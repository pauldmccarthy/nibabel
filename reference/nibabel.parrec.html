<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Neuroimaging in Python &mdash; NiBabel 2.0.2 documentation</title>
    
    <link rel="stylesheet" href="../_static/nibabel.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="NiBabel 2.0.2 documentation" href="../index.html" />
    <link rel="up" title="API Documentation" href="../api.html" />
    <link rel="next" title="trackvis" href="nibabel.trackvis.html" />
    <link rel="prev" title="ecat" href="nibabel.ecat.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience">

  </head>
  <body role="document">
<div style="background-color: white; text-align: left; padding-left: 150px; padding-bottom:50px; padding-top:20px; background-image: url(../_static/nipy-logo-bg-138x120.png); background-repeat: no-repeat;">
<h1>NiBabel</h1>
<h3 style="margin-top:-5px;color:#2f83c8">Access a cacophony of neuro-imaging file formats</h3>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="nibabel.trackvis.html" title="trackvis"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="nibabel.ecat.html" title="ecat"
             accesskey="P">previous</a> |</li>
  <li><a href="http://nipy.org/">Community</a> |&nbsp;</li>
  <li><a href="../index.html">NiBabel Home</a> |&nbsp;</li>
  <li><a href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing list</a> |&nbsp;</li>
  <li><a href="legal.html">License</a> |&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../api.html" accesskey="U">API Documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">parrec</span></code></a><ul>
<li><a class="reference internal" href="#par-file-format">PAR file format</a><ul>
<li><a class="reference internal" href="#general-information">General information</a></li>
<li><a class="reference internal" href="#image-information">Image information</a></li>
</ul>
</li>
<li><a class="reference internal" href="#orientation">Orientation</a></li>
<li><a class="reference internal" href="#data-type">Data type</a></li>
<li><a class="reference internal" href="#parrecarrayproxy"><code class="docutils literal"><span class="pre">PARRECArrayProxy</span></code></a></li>
<li><a class="reference internal" href="#parrecerror"><code class="docutils literal"><span class="pre">PARRECError</span></code></a></li>
<li><a class="reference internal" href="#parrecheader"><code class="docutils literal"><span class="pre">PARRECHeader</span></code></a></li>
<li><a class="reference internal" href="#parrecimage"><code class="docutils literal"><span class="pre">PARRECImage</span></code></a></li>
<li><a class="reference internal" href="#load">load</a></li>
<li><a class="reference internal" href="#one-line">one_line</a></li>
<li><a class="reference internal" href="#parse-par-header">parse_PAR_header</a></li>
<li><a class="reference internal" href="#vol-is-full">vol_is_full</a></li>
<li><a class="reference internal" href="#vol-numbers">vol_numbers</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="nibabel.ecat.html"
                        title="previous chapter"><code class="docutils literal"><span class="pre">ecat</span></code></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="nibabel.trackvis.html"
                        title="next chapter"><code class="docutils literal"><span class="pre">trackvis</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/nibabel.parrec.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<p><img src="../_static/reggie.png" alt="Reggie -- the one" /></p>

        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-nibabel.parrec">
<span id="parrec"></span><h1><code class="xref py py-mod docutils literal"><span class="pre">parrec</span></code><a class="headerlink" href="#module-nibabel.parrec" title="Permalink to this headline">¶</a></h1>
<p>Read images in PAR/REC format.</p>
<p>This is yet another MRI image format generated by Philips scanners. It is an
ASCII header (PAR) plus a binary blob (REC).</p>
<p>This implementation aims to read version 4 and 4.2 of this format. Other
versions could probably be supported, but we need example images to test
against.  If you want us to support another version, and have an image we can
add to the test suite, let us know.  You would make us very happy by submitting
a pull request.</p>
<div class="section" id="par-file-format">
<h2>PAR file format<a class="headerlink" href="#par-file-format" title="Permalink to this headline">¶</a></h2>
<p>The PAR format appears to have two sections:</p>
<div class="section" id="general-information">
<h3>General information<a class="headerlink" href="#general-information" title="Permalink to this headline">¶</a></h3>
<p>This is a set of lines each giving one key : value pair, examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>.    EPI factor        &lt;0,1=no EPI&gt;     :   39
.    Dynamic scan      &lt;0=no 1=yes&gt; ?   :   1
.    Diffusion         &lt;0=no 1=yes&gt; ?   :   0
</pre></div>
</div>
<p>(from nibabe/tests/data/phantom_EPI_asc_CLEAR_2_1.PAR)</p>
</div>
<div class="section" id="image-information">
<h3>Image information<a class="headerlink" href="#image-information" title="Permalink to this headline">¶</a></h3>
<p>There is a <code class="docutils literal"><span class="pre">#</span></code> prefixed list of fields under the heading &#8220;IMAGE INFORMATION
DEFINITION&#8221;.  From the same file, here is the start of this list:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># === IMAGE INFORMATION DEFINITION =============================================</span>
<span class="c1">#  The rest of this file contains ONE line per image, this line contains the following information:</span>
<span class="c1">#</span>
<span class="c1">#  slice number                             (integer)</span>
<span class="c1">#  echo number                              (integer)</span>
<span class="c1">#  dynamic scan number                      (integer)</span>
</pre></div>
</div>
<p>There follows a space separated table with values for these fields, each row
containing all the named values. Here&#8217;s the first few lines from the example
file above:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span># === IMAGE INFORMATION ==========================================================
#  sl ec  dyn ph ty    idx pix scan% rec size                (re)scale              window        angulation              offcentre        thick   gap   info      spacing     echo     dtime   ttime    diff  avg  flip    freq   RR-int  turbo delay b grad cont anis         diffusion       L.ty

1   1    1  1 0 2     0  16    62   64   64     0.00000   1.29035 4.28404e-003  1070  1860 -13.26  -0.00  -0.00    2.51   -0.81   -8.69  6.000  2.000 0 1 0 2  3.750  3.750  30.00    0.00     0.00    0.00   0   90.00     0    0    0    39   0.0  1   1    8    0   0.000    0.000    0.000  1
2   1    1  1 0 2     1  16    62   64   64     0.00000   1.29035 4.28404e-003  1122  1951 -13.26  -0.00  -0.00    2.51    6.98  -10.53  6.000  2.000 0 1 0 2  3.750  3.750  30.00    0.00     0.00    0.00   0   90.00     0    0    0    39   0.0  1   1    8    0   0.000    0.000    0.000  1
3   1    1  1 0 2     2  16    62   64   64     0.00000   1.29035 4.28404e-003  1137  1977 -13.26  -0.00  -0.00    2.51   14.77  -12.36  6.000  2.000 0 1 0 2  3.750  3.750  30.00    0.00     0.00    0.00   0   90.00     0    0    0    39   0.0  1   1    8    0   0.000    0.000    0.000  1
</pre></div>
</div>
</div>
</div>
<div class="section" id="orientation">
<h2>Orientation<a class="headerlink" href="#orientation" title="Permalink to this headline">¶</a></h2>
<p>PAR files refer to orientations &#8220;ap&#8221;, &#8220;fh&#8221; and &#8220;rl&#8221;.</p>
<p>Nibabel&#8217;s required affine output axes are RAS (left to Right, posterior to
Anterior, inferior to Superior). The correspondence of the PAR file&#8217;s axes to
RAS axes is:</p>
<ul class="simple">
<li>ap = anterior -&gt; posterior = negative A in RAS</li>
<li>fh = foot -&gt; head = S in RAS</li>
<li>rl = right -&gt; left = negative R in RAS</li>
</ul>
<p>The orientation of the PAR file axes corresponds to DICOM&#8217;s LPS coordinate
system (right to Left, anterior to Posterior, inferior to Superior), but in a
different order.</p>
<p>We call the PAR file&#8217;s axis system &#8220;PSL&#8221; (Posterior, Superior, Left)</p>
</div>
<div class="section" id="data-type">
<h2>Data type<a class="headerlink" href="#data-type" title="Permalink to this headline">¶</a></h2>
<p>It seems that everyone agrees that Philips stores REC data in little-endian
format - see <a class="reference external" href="https://github.com/nipy/nibabel/issues/274">https://github.com/nipy/nibabel/issues/274</a></p>
<p>Philips XML header files, and some previous experience, suggest that the REC
data is always stored as 8 or 16 bit unsigned integers - see
<a class="reference external" href="https://github.com/nipy/nibabel/issues/275">https://github.com/nipy/nibabel/issues/275</a></p>
</div>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.parrec.PARRECArrayProxy" title="nibabel.parrec.PARRECArrayProxy"><code class="xref py py-obj docutils literal"><span class="pre">PARRECArrayProxy</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Initialize PARREC array proxy</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.parrec.PARRECError" title="nibabel.parrec.PARRECError"><code class="xref py py-obj docutils literal"><span class="pre">PARRECError</span></code></a></td>
<td>Exception for PAR/REC format related problems.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.parrec.PARRECHeader" title="nibabel.parrec.PARRECHeader"><code class="xref py py-obj docutils literal"><span class="pre">PARRECHeader</span></code></a>(info,&nbsp;image_defs[,&nbsp;...])</td>
<td>PAR/REC header</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.parrec.PARRECImage" title="nibabel.parrec.PARRECImage"><code class="xref py py-obj docutils literal"><span class="pre">PARRECImage</span></code></a>(dataobj,&nbsp;affine[,&nbsp;header,&nbsp;...])</td>
<td>PAR/REC image</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.parrec.load" title="nibabel.parrec.load"><code class="xref py py-obj docutils literal"><span class="pre">load</span></code></a></td>
<td>Create PARREC image from filename <cite>filename</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.parrec.one_line" title="nibabel.parrec.one_line"><code class="xref py py-obj docutils literal"><span class="pre">one_line</span></code></a>(long_str)</td>
<td>Make maybe mutli-line <cite>long_str</cite> into one long line</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.parrec.parse_PAR_header" title="nibabel.parrec.parse_PAR_header"><code class="xref py py-obj docutils literal"><span class="pre">parse_PAR_header</span></code></a>(fobj)</td>
<td>Parse a PAR header and aggregate all information into useful containers.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nibabel.parrec.vol_is_full" title="nibabel.parrec.vol_is_full"><code class="xref py py-obj docutils literal"><span class="pre">vol_is_full</span></code></a>(slice_nos,&nbsp;slice_max[,&nbsp;slice_min])</td>
<td>Vector with True for slices in complete volume, False otherwise</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nibabel.parrec.vol_numbers" title="nibabel.parrec.vol_numbers"><code class="xref py py-obj docutils literal"><span class="pre">vol_numbers</span></code></a>(slice_nos)</td>
<td>Calculate volume numbers inferred from slice numbers <cite>slice_nos</cite></td>
</tr>
</tbody>
</table>
<div class="section" id="parrecarrayproxy">
<h2><a class="reference internal" href="#nibabel.parrec.PARRECArrayProxy" title="nibabel.parrec.PARRECArrayProxy"><code class="xref py py-class docutils literal"><span class="pre">PARRECArrayProxy</span></code></a><a class="headerlink" href="#parrecarrayproxy" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.parrec.PARRECArrayProxy">
<em class="property">class </em><code class="descclassname">nibabel.parrec.</code><code class="descname">PARRECArrayProxy</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECArrayProxy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Initialize PARREC array proxy</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>file_like</strong> : file-like object</p>
<blockquote>
<div><p>Filename or object implementing <code class="docutils literal"><span class="pre">read,</span> <span class="pre">seek,</span> <span class="pre">tell</span></code></p>
</div></blockquote>
<p><strong>header</strong> : PARRECHeader instance</p>
<blockquote>
<div><p>Implementing <code class="docutils literal"><span class="pre">get_data_shape,</span> <span class="pre">get_data_dtype</span></code>,
<code class="docutils literal"><span class="pre">get_sorted_slice_indices</span></code>, <code class="docutils literal"><span class="pre">get_data_scaling</span></code>,
<code class="docutils literal"><span class="pre">get_rec_shape</span></code>.</p>
</div></blockquote>
<p><strong>mmap</strong> : {True, False, &#8216;c&#8217;, &#8216;r&#8217;}, optional, keyword only</p>
<blockquote>
<div><p><cite>mmap</cite> controls the use of numpy memory mapping for reading data.
If False, do not try numpy <code class="docutils literal"><span class="pre">memmap</span></code> for data array.  If one of
{&#8216;c&#8217;, &#8216;r&#8217;}, try numpy memmap with <code class="docutils literal"><span class="pre">mode=mmap</span></code>.  A <cite>mmap</cite> value of
True gives the same behavior as <code class="docutils literal"><span class="pre">mmap='c'</span></code>.  If <cite>file_like</cite>
cannot be memory-mapped, ignore <cite>mmap</cite> value and read array from
file.</p>
</div></blockquote>
<p><strong>scaling</strong> : {&#8216;fp&#8217;, &#8216;dv&#8217;}, optional, keyword only</p>
<blockquote class="last">
<div><p>Type of scaling to use - see header <code class="docutils literal"><span class="pre">get_data_scaling</span></code> method.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nibabel.parrec.PARRECArrayProxy.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECArrayProxy.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize PARREC array proxy</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>file_like</strong> : file-like object</p>
<blockquote>
<div><p>Filename or object implementing <code class="docutils literal"><span class="pre">read,</span> <span class="pre">seek,</span> <span class="pre">tell</span></code></p>
</div></blockquote>
<p><strong>header</strong> : PARRECHeader instance</p>
<blockquote>
<div><p>Implementing <code class="docutils literal"><span class="pre">get_data_shape,</span> <span class="pre">get_data_dtype</span></code>,
<code class="docutils literal"><span class="pre">get_sorted_slice_indices</span></code>, <code class="docutils literal"><span class="pre">get_data_scaling</span></code>,
<code class="docutils literal"><span class="pre">get_rec_shape</span></code>.</p>
</div></blockquote>
<p><strong>mmap</strong> : {True, False, &#8216;c&#8217;, &#8216;r&#8217;}, optional, keyword only</p>
<blockquote>
<div><p><cite>mmap</cite> controls the use of numpy memory mapping for reading data.
If False, do not try numpy <code class="docutils literal"><span class="pre">memmap</span></code> for data array.  If one of
{&#8216;c&#8217;, &#8216;r&#8217;}, try numpy memmap with <code class="docutils literal"><span class="pre">mode=mmap</span></code>.  A <cite>mmap</cite> value of
True gives the same behavior as <code class="docutils literal"><span class="pre">mmap='c'</span></code>.  If <cite>file_like</cite>
cannot be memory-mapped, ignore <cite>mmap</cite> value and read array from
file.</p>
</div></blockquote>
<p><strong>scaling</strong> : {&#8216;fp&#8217;, &#8216;dv&#8217;}, optional, keyword only</p>
<blockquote class="last">
<div><p>Type of scaling to use - see header <code class="docutils literal"><span class="pre">get_data_scaling</span></code> method.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.parrec.PARRECArrayProxy.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#nibabel.parrec.PARRECArrayProxy.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECArrayProxy.get_unscaled">
<code class="descname">get_unscaled</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECArrayProxy.get_unscaled" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.parrec.PARRECArrayProxy.is_proxy">
<code class="descname">is_proxy</code><a class="headerlink" href="#nibabel.parrec.PARRECArrayProxy.is_proxy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.parrec.PARRECArrayProxy.shape">
<code class="descname">shape</code><a class="headerlink" href="#nibabel.parrec.PARRECArrayProxy.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="parrecerror">
<h2><a class="reference internal" href="#nibabel.parrec.PARRECError" title="nibabel.parrec.PARRECError"><code class="xref py py-class docutils literal"><span class="pre">PARRECError</span></code></a><a class="headerlink" href="#parrecerror" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.parrec.PARRECError">
<em class="property">class </em><code class="descclassname">nibabel.parrec.</code><code class="descname">PARRECError</code><a class="headerlink" href="#nibabel.parrec.PARRECError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Exception for PAR/REC format related problems.</p>
<p>To be raised whenever PAR/REC is not happy, or we are not happy with
PAR/REC.</p>
<dl class="method">
<dt id="nibabel.parrec.PARRECError.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECError.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="parrecheader">
<h2><a class="reference internal" href="#nibabel.parrec.PARRECHeader" title="nibabel.parrec.PARRECHeader"><code class="xref py py-class docutils literal"><span class="pre">PARRECHeader</span></code></a><a class="headerlink" href="#parrecheader" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.parrec.PARRECHeader">
<em class="property">class </em><code class="descclassname">nibabel.parrec.</code><code class="descname">PARRECHeader</code><span class="sig-paren">(</span><em>info</em>, <em>image_defs</em>, <em>permit_truncated=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nibabel.spatialimages.html#nibabel.spatialimages.Header" title="nibabel.spatialimages.Header"><code class="xref py py-class docutils literal"><span class="pre">nibabel.spatialimages.Header</span></code></a></p>
<p>PAR/REC header</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>info</strong> : dict</p>
<blockquote>
<div><p>&#8220;General information&#8221; from the PAR file (as returned by
<cite>parse_PAR_header()</cite>).</p>
</div></blockquote>
<p><strong>image_defs</strong> : array</p>
<blockquote>
<div><p>Structured array with image definitions from the PAR file (as
returned by <cite>parse_PAR_header()</cite>).</p>
</div></blockquote>
<p><strong>permit_truncated</strong> : bool, optional</p>
<blockquote class="last">
<div><p>If True, a warning is emitted instead of an error when a truncated
recording is detected.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>info</em>, <em>image_defs</em>, <em>permit_truncated=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>info</strong> : dict</p>
<blockquote>
<div><p>&#8220;General information&#8221; from the PAR file (as returned by
<cite>parse_PAR_header()</cite>).</p>
</div></blockquote>
<p><strong>image_defs</strong> : array</p>
<blockquote>
<div><p>Structured array with image definitions from the PAR file (as
returned by <cite>parse_PAR_header()</cite>).</p>
</div></blockquote>
<p><strong>permit_truncated</strong> : bool, optional</p>
<blockquote class="last">
<div><p>If True, a warning is emitted instead of an error when a truncated
recording is detected.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.as_analyze_map">
<code class="descname">as_analyze_map</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.as_analyze_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert PAR parameters to NIFTI1 format</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="nibabel.parrec.PARRECHeader.from_fileobj">
<em class="property">classmethod </em><code class="descname">from_fileobj</code><span class="sig-paren">(</span><em>klass</em>, <em>fileobj</em>, <em>permit_truncated=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.from_fileobj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="nibabel.parrec.PARRECHeader.from_header">
<em class="property">classmethod </em><code class="descname">from_header</code><span class="sig-paren">(</span><em>klass</em>, <em>header=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.from_header" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_affine">
<code class="descname">get_affine</code><span class="sig-paren">(</span><em>origin='scanner'</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute affine transformation into scanner space.</p>
<p>The method only considers global rotation and offset settings in the
header and ignores potentially deviating information in the image
definitions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>origin</strong> : {&#8216;scanner&#8217;, &#8216;fov&#8217;}</p>
<blockquote>
<div><p>Transformation origin. By default the transformation is computed
relative to the scanner&#8217;s iso center. If &#8216;fov&#8217; is requested the
transformation origin will be the center of the field of view
instead.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>aff</strong> : (4, 4) array</p>
<blockquote class="last">
<div><p>4x4 array, with output axis order corresponding to RAS or (x,y,z)
or (lr, pa, fh).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Transformations appear to be specified in (ap, fh, rl) axes.  The
orientation of data is recorded in the &#8220;slice orientation&#8221; field of the
PAR header &#8220;General Information&#8221;.</p>
<p>We need to:</p>
<ul class="simple">
<li>translate to coordinates in terms of the center of the FOV</li>
<li>apply voxel size scaling</li>
<li>reorder / flip the data to Philips&#8217; PSL axes</li>
<li>apply the rotations</li>
<li>apply any isocenter scaling offset if <cite>origin</cite> == &#8220;scanner&#8221;</li>
<li>reorder and flip to RAS axes</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_bvals_bvecs">
<code class="descname">get_bvals_bvecs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_bvals_bvecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get bvals and bvecs from data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>b_vals</strong> : None or array</p>
<blockquote>
<div><p>Array of b values, shape (n_directions,), or None if not a
diffusion acquisition.</p>
</div></blockquote>
<p><strong>b_vectors</strong> : None or array</p>
<blockquote class="last">
<div><p>Array of b vectors, shape (n_directions, 3), or None if not a
diffusion acquisition.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_data_offset">
<code class="descname">get_data_offset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_data_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>PAR header always has 0 data offset (into REC file)</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_data_scaling">
<code class="descname">get_data_scaling</code><span class="sig-paren">(</span><em>method='dv'</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_data_scaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns scaling slope and intercept.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>method</strong> : {&#8216;fp&#8217;, &#8216;dv&#8217;}</p>
<blockquote>
<div><p>Scaling settings to be reported &#8211; see notes below.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>slope</strong> : array</p>
<blockquote>
<div><p>scaling slope</p>
</div></blockquote>
<p><strong>intercept</strong> : array</p>
<blockquote class="last">
<div><p>scaling intercept</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The PAR header contains two different scaling settings: &#8216;dv&#8217; (value on
console) and &#8216;fp&#8217; (floating point value). Here is how they are defined:</p>
<p>PV: value in REC
RS: rescale slope
RI: rescale intercept
SS: scale slope</p>
<p>DV = PV * RS + RI
FP = DV / (RS * SS)</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_echo_train_length">
<code class="descname">get_echo_train_length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_echo_train_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Echo train length of the recording</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_q_vectors">
<code class="descname">get_q_vectors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_q_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Q vectors from the data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>q_vectors</strong> : None or array</p>
<blockquote class="last">
<div><p>Array of q vectors (bvals * bvecs), or None if not a diffusion
acquisition.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_rec_shape">
<code class="descname">get_rec_shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_rec_shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_slice_orientation">
<code class="descname">get_slice_orientation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_slice_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the slice orientation label.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>orientation</strong> : {&#8216;transverse&#8217;, &#8216;sagittal&#8217;, &#8216;coronal&#8217;}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_sorted_slice_indices">
<code class="descname">get_sorted_slice_indices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_sorted_slice_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Indices to sort (and maybe discard) slices in REC file</p>
<p>Returns list for indexing into the last (third) dimension of the REC
data array, and (equivalently) the only dimension of
<code class="docutils literal"><span class="pre">self.image_defs</span></code>.</p>
<p>If the recording is truncated, the returned indices take care of
discarding any indices that are not meant to be used.</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_voxel_size">
<code class="descname">get_voxel_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_voxel_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the spatial extent of a voxel.</p>
<p>Does not include the slice gap in the slice extent.</p>
<p>This function is deprecated and we will remove it in future versions of
nibabel.  Please use <code class="docutils literal"><span class="pre">get_zooms</span></code> instead.  If you need the slice
thickness not including the slice gap, use <code class="docutils literal"><span class="pre">self.image_defs['slice</span>
<span class="pre">thickness']</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>vox_size: shape (3,) ndarray</strong> :</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.get_water_fat_shift">
<code class="descname">get_water_fat_shift</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.get_water_fat_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Water fat shift, in pixels</p>
</dd></dl>

<dl class="method">
<dt id="nibabel.parrec.PARRECHeader.set_data_offset">
<code class="descname">set_data_offset</code><span class="sig-paren">(</span><em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECHeader.set_data_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>PAR header always has 0 data offset (into REC file)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="parrecimage">
<h2><a class="reference internal" href="#nibabel.parrec.PARRECImage" title="nibabel.parrec.PARRECImage"><code class="xref py py-class docutils literal"><span class="pre">PARRECImage</span></code></a><a class="headerlink" href="#parrecimage" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.parrec.PARRECImage">
<em class="property">class </em><code class="descclassname">nibabel.parrec.</code><code class="descname">PARRECImage</code><span class="sig-paren">(</span><em>dataobj</em>, <em>affine</em>, <em>header=None</em>, <em>extra=None</em>, <em>file_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nibabel.spatialimages.html#nibabel.spatialimages.SpatialImage" title="nibabel.spatialimages.SpatialImage"><code class="xref py py-class docutils literal"><span class="pre">nibabel.spatialimages.SpatialImage</span></code></a></p>
<p>PAR/REC image</p>
<p>Initialize image</p>
<p>The image is a combination of (array, affine matrix, header), with
optional metadata in <cite>extra</cite>, and filename / file-like objects contained
in the <cite>file_map</cite> mapping.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dataobj</strong> : object</p>
<blockquote>
<div><p>Object containg image data.  It should be some object that retuns an
array from <code class="docutils literal"><span class="pre">np.asanyarray</span></code>.  It should have a <code class="docutils literal"><span class="pre">shape</span></code> attribute
or property</p>
</div></blockquote>
<p><strong>affine</strong> : None or (4,4) array-like</p>
<blockquote>
<div><p>homogenous affine giving relationship between voxel coordinates and
world coordinates.  Affine can also be None.  In this case,
<code class="docutils literal"><span class="pre">obj.affine</span></code> also returns None, and the affine as written to disk
will depend on the file format.</p>
</div></blockquote>
<p><strong>header</strong> : None or mapping or header instance, optional</p>
<blockquote>
<div><p>metadata for this image format</p>
</div></blockquote>
<p><strong>extra</strong> : None or mapping, optional</p>
<blockquote>
<div><p>metadata to associate with image that cannot be stored in the
metadata of this image type</p>
</div></blockquote>
<p><strong>file_map</strong> : mapping, optional</p>
<blockquote class="last">
<div><p>mapping giving file information for this image format</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nibabel.parrec.PARRECImage.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>dataobj</em>, <em>affine</em>, <em>header=None</em>, <em>extra=None</em>, <em>file_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECImage.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize image</p>
<p>The image is a combination of (array, affine matrix, header), with
optional metadata in <cite>extra</cite>, and filename / file-like objects contained
in the <cite>file_map</cite> mapping.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dataobj</strong> : object</p>
<blockquote>
<div><p>Object containg image data.  It should be some object that retuns an
array from <code class="docutils literal"><span class="pre">np.asanyarray</span></code>.  It should have a <code class="docutils literal"><span class="pre">shape</span></code> attribute
or property</p>
</div></blockquote>
<p><strong>affine</strong> : None or (4,4) array-like</p>
<blockquote>
<div><p>homogenous affine giving relationship between voxel coordinates and
world coordinates.  Affine can also be None.  In this case,
<code class="docutils literal"><span class="pre">obj.affine</span></code> also returns None, and the affine as written to disk
will depend on the file format.</p>
</div></blockquote>
<p><strong>header</strong> : None or mapping or header instance, optional</p>
<blockquote>
<div><p>metadata for this image format</p>
</div></blockquote>
<p><strong>extra</strong> : None or mapping, optional</p>
<blockquote>
<div><p>metadata to associate with image that cannot be stored in the
metadata of this image type</p>
</div></blockquote>
<p><strong>file_map</strong> : mapping, optional</p>
<blockquote class="last">
<div><p>mapping giving file information for this image format</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.parrec.PARRECImage.ImageArrayProxy">
<code class="descname">ImageArrayProxy</code><a class="headerlink" href="#nibabel.parrec.PARRECImage.ImageArrayProxy" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#nibabel.parrec.PARRECArrayProxy" title="nibabel.parrec.PARRECArrayProxy"><code class="xref py py-class docutils literal"><span class="pre">PARRECArrayProxy</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.parrec.PARRECImage.files_types">
<code class="descname">files_types</code><em class="property"> = (('image', '.rec'), ('header', '.par'))</em><a class="headerlink" href="#nibabel.parrec.PARRECImage.files_types" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="nibabel.parrec.PARRECImage.from_file_map">
<em class="property">classmethod </em><code class="descname">from_file_map</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECImage.from_file_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Create PARREC image from file map <cite>file_map</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>file_map</strong> : dict</p>
<blockquote>
<div><p>dict with keys <code class="docutils literal"><span class="pre">image,</span> <span class="pre">header</span></code> and values being fileholder
objects for the respective REC and PAR files.</p>
</div></blockquote>
<p><strong>mmap</strong> : {True, False, &#8216;c&#8217;, &#8216;r&#8217;}, optional, keyword only</p>
<blockquote>
<div><p><cite>mmap</cite> controls the use of numpy memory mapping for reading image
array data.  If False, do not try numpy <code class="docutils literal"><span class="pre">memmap</span></code> for data array.
If one of {&#8216;c&#8217;, &#8216;r&#8217;}, try numpy memmap with <code class="docutils literal"><span class="pre">mode=mmap</span></code>.  A <cite>mmap</cite>
value of True gives the same behavior as <code class="docutils literal"><span class="pre">mmap='c'</span></code>.  If image
data file cannot be memory-mapped, ignore <cite>mmap</cite> value and read
array from file.</p>
</div></blockquote>
<p><strong>permit_truncated</strong> : {False, True}, optional, keyword-only</p>
<blockquote>
<div><p>If False, raise an error for an image where the header shows signs
that fewer slices / volumes were recorded than were expected.</p>
</div></blockquote>
<p><strong>scaling</strong> : {&#8216;dv&#8217;, &#8216;fp&#8217;}, optional, keyword-only</p>
<blockquote class="last">
<div><p>Scaling method to apply to data (see
<a class="reference internal" href="#nibabel.parrec.PARRECHeader.get_data_scaling" title="nibabel.parrec.PARRECHeader.get_data_scaling"><code class="xref py py-meth docutils literal"><span class="pre">PARRECHeader.get_data_scaling()</span></code></a>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="nibabel.parrec.PARRECImage.from_filename">
<em class="property">classmethod </em><code class="descname">from_filename</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECImage.from_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Create PARREC image from filename <cite>filename</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Filename of &#8220;PAR&#8221; or &#8220;REC&#8221; file</p>
</div></blockquote>
<p><strong>mmap</strong> : {True, False, &#8216;c&#8217;, &#8216;r&#8217;}, optional, keyword only</p>
<blockquote>
<div><p><cite>mmap</cite> controls the use of numpy memory mapping for reading image
array data.  If False, do not try numpy <code class="docutils literal"><span class="pre">memmap</span></code> for data array.
If one of {&#8216;c&#8217;, &#8216;r&#8217;}, try numpy memmap with <code class="docutils literal"><span class="pre">mode=mmap</span></code>.  A <cite>mmap</cite>
value of True gives the same behavior as <code class="docutils literal"><span class="pre">mmap='c'</span></code>.  If image
data file cannot be memory-mapped, ignore <cite>mmap</cite> value and read
array from file.</p>
</div></blockquote>
<p><strong>permit_truncated</strong> : {False, True}, optional, keyword-only</p>
<blockquote>
<div><p>If False, raise an error for an image where the header shows signs
that fewer slices / volumes were recorded than were expected.</p>
</div></blockquote>
<p><strong>scaling</strong> : {&#8216;dv&#8217;, &#8216;fp&#8217;}, optional, keyword-only</p>
<blockquote class="last">
<div><p>Scaling method to apply to data (see
<a class="reference internal" href="#nibabel.parrec.PARRECHeader.get_data_scaling" title="nibabel.parrec.PARRECHeader.get_data_scaling"><code class="xref py py-meth docutils literal"><span class="pre">PARRECHeader.get_data_scaling()</span></code></a>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.parrec.PARRECImage.header_class">
<code class="descname">header_class</code><a class="headerlink" href="#nibabel.parrec.PARRECImage.header_class" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#nibabel.parrec.PARRECHeader" title="nibabel.parrec.PARRECHeader"><code class="xref py py-class docutils literal"><span class="pre">PARRECHeader</span></code></a></p>
</dd></dl>

<dl class="classmethod">
<dt id="nibabel.parrec.PARRECImage.load">
<em class="property">classmethod </em><code class="descname">load</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.PARRECImage.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Create PARREC image from filename <cite>filename</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Filename of &#8220;PAR&#8221; or &#8220;REC&#8221; file</p>
</div></blockquote>
<p><strong>mmap</strong> : {True, False, &#8216;c&#8217;, &#8216;r&#8217;}, optional, keyword only</p>
<blockquote>
<div><p><cite>mmap</cite> controls the use of numpy memory mapping for reading image
array data.  If False, do not try numpy <code class="docutils literal"><span class="pre">memmap</span></code> for data array.
If one of {&#8216;c&#8217;, &#8216;r&#8217;}, try numpy memmap with <code class="docutils literal"><span class="pre">mode=mmap</span></code>.  A <cite>mmap</cite>
value of True gives the same behavior as <code class="docutils literal"><span class="pre">mmap='c'</span></code>.  If image
data file cannot be memory-mapped, ignore <cite>mmap</cite> value and read
array from file.</p>
</div></blockquote>
<p><strong>permit_truncated</strong> : {False, True}, optional, keyword-only</p>
<blockquote>
<div><p>If False, raise an error for an image where the header shows signs
that fewer slices / volumes were recorded than were expected.</p>
</div></blockquote>
<p><strong>scaling</strong> : {&#8216;dv&#8217;, &#8216;fp&#8217;}, optional, keyword-only</p>
<blockquote class="last">
<div><p>Scaling method to apply to data (see
<a class="reference internal" href="#nibabel.parrec.PARRECHeader.get_data_scaling" title="nibabel.parrec.PARRECHeader.get_data_scaling"><code class="xref py py-meth docutils literal"><span class="pre">PARRECHeader.get_data_scaling()</span></code></a>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="load">
<h2>load<a class="headerlink" href="#load" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.parrec.load">
<code class="descclassname">nibabel.parrec.</code><code class="descname">load</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Create PARREC image from filename <cite>filename</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Filename of &#8220;PAR&#8221; or &#8220;REC&#8221; file</p>
</div></blockquote>
<p><strong>mmap</strong> : {True, False, &#8216;c&#8217;, &#8216;r&#8217;}, optional, keyword only</p>
<blockquote>
<div><p><cite>mmap</cite> controls the use of numpy memory mapping for reading image
array data.  If False, do not try numpy <code class="docutils literal"><span class="pre">memmap</span></code> for data array.
If one of {&#8216;c&#8217;, &#8216;r&#8217;}, try numpy memmap with <code class="docutils literal"><span class="pre">mode=mmap</span></code>.  A <cite>mmap</cite>
value of True gives the same behavior as <code class="docutils literal"><span class="pre">mmap='c'</span></code>.  If image
data file cannot be memory-mapped, ignore <cite>mmap</cite> value and read
array from file.</p>
</div></blockquote>
<p><strong>permit_truncated</strong> : {False, True}, optional, keyword-only</p>
<blockquote>
<div><p>If False, raise an error for an image where the header shows signs
that fewer slices / volumes were recorded than were expected.</p>
</div></blockquote>
<p><strong>scaling</strong> : {&#8216;dv&#8217;, &#8216;fp&#8217;}, optional, keyword-only</p>
<blockquote class="last">
<div><p>Scaling method to apply to data (see
<a class="reference internal" href="#nibabel.parrec.PARRECHeader.get_data_scaling" title="nibabel.parrec.PARRECHeader.get_data_scaling"><code class="xref py py-meth docutils literal"><span class="pre">PARRECHeader.get_data_scaling()</span></code></a>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="one-line">
<h2>one_line<a class="headerlink" href="#one-line" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.parrec.one_line">
<code class="descclassname">nibabel.parrec.</code><code class="descname">one_line</code><span class="sig-paren">(</span><em>long_str</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.one_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Make maybe mutli-line <cite>long_str</cite> into one long line</p>
</dd></dl>

</div>
<div class="section" id="parse-par-header">
<h2>parse_PAR_header<a class="headerlink" href="#parse-par-header" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.parrec.parse_PAR_header">
<code class="descclassname">nibabel.parrec.</code><code class="descname">parse_PAR_header</code><span class="sig-paren">(</span><em>fobj</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.parse_PAR_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a PAR header and aggregate all information into useful containers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fobj</strong> : file-object</p>
<blockquote>
<div><p>The PAR header file object.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>general_info</strong> : dict</p>
<blockquote>
<div><p>Contains all &#8220;General Information&#8221; from the header file</p>
</div></blockquote>
<p><strong>image_info</strong> : ndarray</p>
<blockquote class="last">
<div><p>Structured array with fields giving all &#8220;Image information&#8221; in the
header</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="vol-is-full">
<h2>vol_is_full<a class="headerlink" href="#vol-is-full" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.parrec.vol_is_full">
<code class="descclassname">nibabel.parrec.</code><code class="descname">vol_is_full</code><span class="sig-paren">(</span><em>slice_nos</em>, <em>slice_max</em>, <em>slice_min=1</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.vol_is_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector with True for slices in complete volume, False otherwise</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>slice_nos</strong> : sequence</p>
<blockquote>
<div><p>Sequence of slice numbers, e.g. <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4]</span></code>.</p>
</div></blockquote>
<p><strong>slice_max</strong> : int</p>
<blockquote>
<div><p>Highest slice number for a full slice set.  Slice set will be
<code class="docutils literal"><span class="pre">range(slice_min,</span> <span class="pre">slice_max+1)</span></code>.</p>
</div></blockquote>
<p><strong>slice_min</strong> : int</p>
<blockquote>
<div><p>Lowest slice number for full slice set.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>is_full</strong> : array</p>
<blockquote>
<div><p>Bool vector with True for slices in full volumes, False for slices in
partial volumes.  A full volume is a volume with all slices in the
<code class="docutils literal"><span class="pre">slice</span> <span class="pre">set</span></code> as defined above.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> :</p>
<blockquote class="last">
<div><p>if any <cite>slice_nos</cite> value is outside slice set.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="vol-numbers">
<h2>vol_numbers<a class="headerlink" href="#vol-numbers" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.parrec.vol_numbers">
<code class="descclassname">nibabel.parrec.</code><code class="descname">vol_numbers</code><span class="sig-paren">(</span><em>slice_nos</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.parrec.vol_numbers" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate volume numbers inferred from slice numbers <cite>slice_nos</cite></p>
<p>The volume number for each slice is the number of times this slice has
occurred previously in the <cite>slice_nos</cite> sequence</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>slice_nos</strong> : sequence</p>
<blockquote>
<div><p>Sequence of slice numbers, e.g. <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4]</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>vol_nos</strong> : list</p>
<blockquote class="last">
<div><p>A list, the same length of <cite>slice_nos</cite> giving the volume number for
each corresponding slice number.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2006-2015, Matthew Brett, Michael Hanke and Eric Larson &lt;nipy-devel@neuroimaging.scipy.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>