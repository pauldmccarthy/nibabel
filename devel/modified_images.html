<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Neuroimaging in Python &mdash; NiBabel 2.0.2 documentation</title>
    
    <link rel="stylesheet" href="../_static/nibabel.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="NiBabel 2.0.2 documentation" href="../index.html" />
    <link rel="up" title="Developer discussions" href="devdiscuss.html" />
    <link rel="next" title="Design of data packages for the nibabel and the nipy suite" href="data_pkg_design.html" />
    <link rel="prev" title="Image use-cases in SPM" href="spm_use.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience">

  </head>
  <body role="document">
<div style="background-color: white; text-align: left; padding-left: 150px; padding-bottom:50px; padding-top:20px; background-image: url(../_static/nipy-logo-bg-138x120.png); background-repeat: no-repeat;">
<h1>NiBabel</h1>
<h3 style="margin-top:-5px;color:#2f83c8">Access a cacophony of neuro-imaging file formats</h3>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="data_pkg_design.html" title="Design of data packages for the nibabel and the nipy suite"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="spm_use.html" title="Image use-cases in SPM"
             accesskey="P">previous</a> |</li>
  <li><a href="http://nipy.org/">Community</a> |&nbsp;</li>
  <li><a href="../index.html">NiBabel Home</a> |&nbsp;</li>
  <li><a href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing list</a> |&nbsp;</li>
  <li><a href="legal.html">License</a> |&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >Developer documentation page</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="devdiscuss.html" accesskey="U">Developer discussions</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Keeping track of whether images have been modified since load</a><ul>
<li><a class="reference internal" href="#summary">Summary</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#possible-implementation">Possible implementation</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="spm_use.html"
                        title="previous chapter">Image use-cases in SPM</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="data_pkg_design.html"
                        title="next chapter">Design of data packages for the nibabel and the nipy suite</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/devel/modified_images.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<p><img src="../_static/reggie.png" alt="Reggie -- the one" /></p>

        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="keeping-track-of-whether-images-have-been-modified-since-load">
<h1>Keeping track of whether images have been modified since load<a class="headerlink" href="#keeping-track-of-whether-images-have-been-modified-since-load" title="Permalink to this headline">¶</a></h1>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>This is a discussion of a missing feature in nibabel: the ability to keep
track of whether an image object in memory still corresponds to an image file
(or files) on disk.</p>
</div>
<div class="section" id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h2>
<p>We may need to know whether the image in memory corresponds to the image file
on disk.</p>
<p>For example, we often need to get filenames for images when passing
images to external programs. Imagine a realignment, in this case, in <a class="reference external" href="http://nipy.org/nipy">nipy</a>
(the package):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">nipy</span>
<span class="n">img1</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;meanfunctional.nii&#39;</span><span class="p">)</span>
<span class="n">img2</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;anatomical.nii&#39;</span><span class="p">)</span>
<span class="n">realigner</span> <span class="o">=</span> <span class="n">nipy</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">fsl</span><span class="o">.</span><span class="n">flirt</span><span class="p">()</span>
<span class="n">params</span> <span class="o">=</span> <span class="n">realigner</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">img1</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">img2</span><span class="p">)</span>
</pre></div>
</div>
<p>In <code class="docutils literal"><span class="pre">nipy.interfaces.fsl.flirt.run</span></code> there may at some point be calls like:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">source_filename</span> <span class="o">=</span> <span class="n">nipy</span><span class="o">.</span><span class="n">as_filename</span><span class="p">(</span><span class="n">source_img</span><span class="p">)</span>
<span class="n">target_filename</span> <span class="o">=</span> <span class="n">nipy</span><span class="o">.</span><span class="n">as_filename</span><span class="p">(</span><span class="n">target_img</span><span class="p">)</span>
</pre></div>
</div>
<p>As the authors of the <code class="docutils literal"><span class="pre">flirt.run</span></code> method, we need to make sure that the
<code class="docutils literal"><span class="pre">source_filename</span></code> corresponds to the <code class="docutils literal"><span class="pre">source_img</span></code>.</p>
<p>Of course, in the general case, if <code class="docutils literal"><span class="pre">source_img</span></code> has no corresponding
filename (from <code class="docutils literal"><span class="pre">source_img.get_filename()</span></code>, then we will have to save a copy
to disk, maybe with a temporary filename, and return that temporary name as
<code class="docutils literal"><span class="pre">source_filename</span></code>.</p>
<p>In our particular case, <code class="docutils literal"><span class="pre">source_img</span></code> does have a filename
(<code class="docutils literal"><span class="pre">meanfunctional.nii</span></code>).  We would like to return that as
<code class="docutils literal"><span class="pre">source_filename</span></code>.  The question is, how can we be sure that the user has
done nothing to <code class="docutils literal"><span class="pre">source_img</span></code> to make it diverge from its original state?
Could <code class="docutils literal"><span class="pre">source_img</span></code> have diverged, in memory, from the state recorded in
<code class="docutils literal"><span class="pre">meantunctional.nii</span></code>?</p>
<p>If the image and file have not diverged, we return <code class="docutils literal"><span class="pre">meanfunctional.nii</span></code> as
the <code class="docutils literal"><span class="pre">source_filename</span></code>, otherwise we will have to do something like:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tempfile</span>
<span class="n">fname</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span><span class="s1">&#39;.nii&#39;</span><span class="p">)</span>
<span class="n">img</span> <span class="o">=</span> <span class="n">source_img</span><span class="o">.</span><span class="n">to_filename</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
</pre></div>
</div>
<p>and return <code class="docutils literal"><span class="pre">fname</span></code> as <code class="docutils literal"><span class="pre">source_filename</span></code>.</p>
<p>Another situation where we might like to pass around image objects that are
known to correspond to images on disk is when working in parallel. A set of
nodes may have fast common access to a filesystem on which the images are
stored.  If a master is farming out images to nodes, a master node
distribution jobs to workers might want to check if the image was identical to
something on file and pass around a lightweight (proxied) image (with the data
not loaded into memory), relying on the node pulling the image from disk when
it uses it.</p>
</div>
<div class="section" id="possible-implementation">
<h2>Possible implementation<a class="headerlink" href="#possible-implementation" title="Permalink to this headline">¶</a></h2>
<p>One implementation is to have <code class="docutils literal"><span class="pre">dirty</span></code> flag, which, if set, would tell
you that the image might not correspond to the disk file.  We set this
flag when anyone asks for the data, on the basis that the user may then
do something to the data and you can&#8217;t know if they have:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">img</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;some_image.nii&#39;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
<span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">img2</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;some_image.nii&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">img2</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span> <span class="o">==</span> <span class="n">img</span><span class="o">.</span><span class="n">get_data</span><span class="p">())</span>
</pre></div>
</div>
<p>The image consists of the data, the affine and a header.  In order to
keep track of the header and affine, we could cache them when loading
the image:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">img</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;some_image.nii&#39;</span><span class="p">)</span>
<span class="n">hdr</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">header</span>
<span class="k">assert</span> <span class="n">img</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;header&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">img</span><span class="o">.</span><span class="n">header</span>
<span class="n">hdr</span><span class="o">.</span><span class="n">set_data_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">img</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;header&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">img</span><span class="o">.</span><span class="n">header</span>
</pre></div>
</div>
<p>When we need to know whether the image object and image file correspond, we
could check the current header and current affine (the header may be separate
from the affine for an SPM Analyze image) against their cached copies, if they
are the same and the &#8216;dirty&#8217; flag has not been set by a previous call to
<code class="docutils literal"><span class="pre">get_data()</span></code>, we know that the image file does correspond to the image
object.</p>
<p>This may be OK for small bits of memory like the affine and the header,
but would quickly become prohibitive for larger image metadata such as
large nifti header extensions.  We could just always assume that images
with large header extensions are <em>not</em> the same as for on disk.</p>
<p>The user might be able to override the result of these checks directly:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">img</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;some_image.nii&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">img</span><span class="o">.</span><span class="n">is_dirty</span> <span class="o">==</span> <span class="bp">False</span>
<span class="n">hdr</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">header</span>
<span class="n">hdr</span><span class="o">.</span><span class="n">set_data_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">img</span><span class="o">.</span><span class="n">is_dirty</span> <span class="o">==</span> <span class="bp">True</span>
<span class="n">img</span><span class="o">.</span><span class="n">is_dirty</span> <span class="o">==</span> <span class="bp">False</span>
</pre></div>
</div>
<p>The checks are magic behind the scenes stuff that do some safe optimization
(in the sense that we are not re-saving the data if that is not necessary),
but drops back to the default (re-saving the data) if there is any
uncertainty, or the cost is too high to be able to check.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2006-2015, Matthew Brett, Michael Hanke and Eric Larson &lt;nipy-devel@neuroimaging.scipy.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>